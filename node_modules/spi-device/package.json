{
  "_args": [
    [
      {
        "raw": "spi-device@^2.0.4",
        "scope": null,
        "escapedName": "spi-device",
        "name": "spi-device",
        "rawSpec": "^2.0.4",
        "spec": ">=2.0.4 <3.0.0",
        "type": "range"
      },
      "/opt/iobroker/node_modules/iobroker.raspilc"
    ]
  ],
  "_from": "spi-device@^2.0.4",
  "_hasShrinkwrap": false,
  "_id": "spi-device@2.0.4",
  "_location": "/iobroker.raspilc/spi-device",
  "_nodeVersion": "8.10.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/spi-device_2.0.4_1538220427090_0.4762297822314201"
  },
  "_npmUser": {
    "name": "fivdi",
    "email": "bdscooke@gmail.com"
  },
  "_npmVersion": "5.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "spi-device@^2.0.4",
    "scope": null,
    "escapedName": "spi-device",
    "name": "spi-device",
    "rawSpec": "^2.0.4",
    "spec": ">=2.0.4 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/iobroker.raspilc"
  ],
  "_resolved": "https://registry.npmjs.org/spi-device/-/spi-device-2.0.4.tgz",
  "_shasum": "d25e2677b55b774a6cc4455f6b6c27c3b92cff24",
  "_shrinkwrap": null,
  "_spec": "spi-device@^2.0.4",
  "_where": "/opt/iobroker/node_modules/iobroker.raspilc",
  "author": {
    "name": "fivdi"
  },
  "bugs": {
    "url": "https://github.com/fivdi/spi-device/issues"
  },
  "dependencies": {
    "bindings": "^1.3.0",
    "nan": "^2.11.1"
  },
  "description": "SPI serial bus access with Node.js",
  "devDependencies": {},
  "directories": {
    "example": "example",
    "test": "test"
  },
  "dist": {
    "integrity": "sha512-RtRnrUcwnSZLIyGvG3Vr0K3G4j4K5rUxXzy/rR70H73AJku/+ROyp8CEqzxxBvoVTaAfirs9a0eSnNC/1E3UuQ==",
    "shasum": "d25e2677b55b774a6cc4455f6b6c27c3b92cff24",
    "tarball": "https://registry.npmjs.org/spi-device/-/spi-device-2.0.4.tgz",
    "fileCount": 32,
    "unpackedSize": 312216,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbr2GLCRA9TVsSAnZWagAA95sP/32NvGETqYxjYKvC2mI8\njmjUeRl6VHbrTDre09liLYaUtb51RMdcpOuCsyd2HPoN5w17s0x1H0f7F+Mp\nDFV5+YBZIMSuqeSVg9h36ThJKtklzDW+YYjeJHezDlTI19QxlW71NRbw9V41\n7JwA5TuXzhDWHr+B3LjzLmrZwytCIrnonILP8LHCtIqrhbXhLcGf6Oq0BFFU\nGeSxaJcQ0iNIuqPcU2m794ncKJEMRU1AU4jKpE+MVF79wlYyzLBAp38pMMWq\nfsetrSrl+t8DyxELFZZszHe3/2kYtNLVjQQZYG0mnEntbolhuEMo5OSqWJxC\nnHcWcbEyuJmvvDJHBnUDVHS46xGtGKjLr4RgAeF6ikVCtXk57HdlJdT+XKTO\nsNNskfLn9AqHwKCvIeBZRWWL1/VCr8wJqiAxXxchtelhMmNWbzMiixhFPoME\nS1zKgpCaBsw7FZl0hWk7MdDyfaTToXVFERLfWBzzP5VYALwPX1ZZBzBoduI4\ncvTmEH/RoESqDhNUtDNTlD1YkeJVbnZNriRhRFWT89sErXaH7s7hP5L9koK8\nfTHq4Yfl+kT0XZuPY7md0BCqFMJxuJp9WQrOpylABGcn7JnxUm6fnJ49f6/3\nuFdQWPTzxEO8oVL0ngc7gq1gBjaKIs1FIqMGeXDxbANuhTGBiCc1O/gJ2VN4\n1svZ\r\n=PKZg\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "engines": {
    "node": ">=4.0.0"
  },
  "gitHead": "8bf0508880bd291f0ee41e38508744be000b51e7",
  "gypfile": true,
  "homepage": "https://github.com/fivdi/spi-device#readme",
  "keywords": [
    "linux",
    "beaglebone",
    "pi",
    "rpi",
    "raspi",
    "raspberry",
    "spi"
  ],
  "license": "MIT",
  "main": "spi-device.js",
  "maintainers": [
    {
      "name": "fivdi",
      "email": "bdscooke@gmail.com"
    }
  ],
  "name": "spi-device",
  "optionalDependencies": {},
  "readme": "# spi-device\n\nSPI serial bus access with **Node.js** on Linux boards like the Raspberry\nPi or BeagleBone. All methods have asynchronous and synchronous forms.\n\nspi-device supports Node.js versions 4, 6, 8 and 10.\n\n[![Mentioned in Awesome Node.js](https://awesome.re/mentioned-badge.svg)](https://github.com/sindresorhus/awesome-nodejs)\n\n## Contents\n\n * [Installation](#installation)\n * [Usage](#usage)\n * [API Documentation](#api-documentation)\n\n## Installation\n\n```\nnpm install spi-device\n```\n\n## Usage\n\nDetermine the temperature using a TMP36 analog temperature sensor wired to\nchannel 5 on an MCP3008 SPI A/D converter.\n\n<img src=\"https://raw.githubusercontent.com/fivdi/spi-device/master/example/pi-mcp3008-tmp36.png\">\n\n```js\nconst spi = require('spi-device');\n\n// The MCP3008 is on bus 0 and it's device 0\nconst mcp3008 = spi.open(0, 0, (err) => {\n  // An SPI message is an array of one or more read+write transfers\n  const message = [{\n    sendBuffer: Buffer.from([0x01, 0xd0, 0x00]), // Sent to read channel 5\n    receiveBuffer: Buffer.alloc(3),              // Raw data read from channel 5\n    byteLength: 3,\n    speedHz: 20000 // Use a low bus speed to get a good reading from the TMP36\n  }];\n\n  if (err) throw err;\n\n  mcp3008.transfer(message, (err, message) => {\n    if (err) throw err;\n\n    // Convert raw value from sensor to celcius and log to console\n    const rawValue = ((message[0].receiveBuffer[1] & 0x03) << 8) +\n      message[0].receiveBuffer[2];\n    const voltage = rawValue * 3.3 / 1023;\n    const celcius = (voltage - 0.5) * 100;\n\n    console.log(celcius);\n  });\n});\n```\n\nspi-device enables low-level access to SPI devices. Often, high-level access\nis required. When this is the case, high-level packages can be built using\nspi-device. An example of such a package is\n[mcp-spi-adc](https://github.com/fivdi/mcp-spi-adc) which provides a high-level\nAPI for accessing an MCP3008 SPI A/D converter and will generally be more\nuseful than the low-level demonstration code shown above.\n\n## API Documentation\n\nAll methods have asynchronous and synchronous forms.\n\nThe asynchronous form always take a completion callback as its last argument.\nThe arguments passed to the completion callback depend on the method, but the\nfirst argument is always reserved for an exception. If the operation was\ncompleted successfully, then the first argument will be null or undefined.\n\nWhen using the synchronous form any exceptions are immediately thrown. You can\nuse try/catch to handle exceptions or allow them to bubble up. \n\n### Functions\n\n- [open(busNumber, deviceNumber[, options], cb)](#openbusnumber-devicenumber-options-cb)\n- [openSync(busNumber, deviceNumber[, options])](#opensyncbusnumber-devicenumber-options)\n\n### Class SpiDevice\n\n- [device.transfer(message, cb)](#devicetransfermessage-cb)\n- [device.transferSync(message)](#devicetransfersyncmessage)\n- [device.getOptions(cb)](#devicegetoptionscb)\n- [device.getOptionsSync()](#devicegetoptionssync)\n- [device.setOptions(options, cb)](#devicesetoptionsoptions-cb)\n- [device.setOptionsSync(options)](#devicesetoptionssyncoptions)\n- [device.close(cb)](#deviceclosecb)\n- [device.closeSync()](#deviceclosesync)\n\n### Constants\n\n- [MODE0](#mode0)\n- [MODE1](#mode1)\n- [MODE2](#mode2)\n- [MODE3](#mode3)\n\n### open(busNumber, deviceNumber[, options], cb)\n- busNumber - the number of the SPI bus to open, 0 for `/dev/spidev0.n`, 1 for `/dev/spidev1.n`, ...\n- deviceNumber - the number of the SPI device to open, 0 for `/dev/spidevn.0`, 1 for `/dev/spidevn.1`, ...\n- options - an optional object specifying device\n[configuration options](#configuration-options)\n- cb - completion callback\n\nAsynchronous open. Returns a new SpiDevice object. The completion callback gets\none argument (err). The SpiDevice object returned should not be used before the\ncompletion callback is called.\n\n### openSync(busNumber, deviceNumber[, options])\n- busNumber - the number of the SPI bus to open, 0 for `/dev/spidev0.n`, 1 for `/dev/spidev1.n`, ...\n- deviceNumber - the number of the SPI device to open, 0 for `/dev/spidevn.0`, 1 for `/dev/spidevn.1`, ...\n- options - an optional object specifying device\n[configuration options](#configuration-options)\n\nSynchronous open. Returns a new SpiDevice object.\n\n### device.transfer(message, cb)\n- message - an array of one or more read+write transfers\n- cb - completion callback\n\nAsynchronous message transfer. An SPI\n[message](#message) is an array of one or\nmore read+write transfers. The completion callback gets two arguments (err,\nmessage). Returns this.\n\n### device.transferSync(message)\n- message - an array of one or more read+write transfers\n\nSynchronous message transfer. An SPI\n[message](#message) is an array of one or\nmore read+write transfers. Returns this.\n\n### device.getOptions(cb)\n- cb - completion callback\n\nAsynchronously read device\n[configuration options](#configuration-options).\nThe completion callback gets two arguments (err, options) where options is an\nobject describing the device configuration options. Returns this.\n\n### device.getOptionsSync()\n\nSynchronously read device\n[configuration options](#configuration-options).\nReturns an object describing the device configuration options.\n\n### device.setOptions(options, cb)\n- options - an object specifying device\n[configuration options](#configuration-options)\n- cb - completion callback\n\nAsynchronously write device\n[configuration options](#configuration-options).\nThe completion callback gets one argument (err). Returns this.\n\n### device.setOptionsSync(options)\n- options - an object specifying device\n[configuration options](#configuration-options)\n\nSynchronously write device\n[configuration options](#configuration-options).\nReturns this.\n\n### device.close(cb)\n- cb - completion callback\n\nAsynchronous close. The completion callback gets one argument (err). Returns\nnull.\n\n### device.closeSync()\n\nSynchronous close. Returns null.\n\n### MODE0\n\nSPI mode number 0.\n\n### MODE1\n\nSPI mode number 1.\n\n### MODE2\n\nSPI mode number 2.\n\n### MODE3\n\nSPI mode number 3.\n\n### Message\n\nAn SPI message is an array of one or more read+write transfers. A transfer\nis an object with the properties listed below. Most of the properties are\noptional. Note that although both sendBuffer and receiveBuffer are optional,\nat least one one of them must be specified.\n\n- byteLength - number, 32-bit, the number of bytes to transfer\n- sendBuffer - optional Buffer, transmit data\n- receiveBuffer - optional Buffer, receive data\n- speedHz - optional number, 32-bit, override of the device's clock frequency\nin Hertz\n- microSecondDelay - optional number, 16-bit, delay after the last bit transfer\nbefore optionally deselecting the device before the next transfer, default 0\n- bitsPerWord - optional number, 8-bit, override of the device's wordsize\n- chipSelectChange - optional boolean, true to deselect device before starting\nthe next transfer, default false\n\n### Configuration Options\n\nDevice configuration options can be optionally specified when a device is\nopened with the `open` or `openSync` methods. They can also be specified at a\nlater point with the `setOptions` or `setOptionsSync` methods. When calling\nthese methods, only the options that need to be set need to be specified in the\noptions object passed to those methods. All options are optional and the\nappropriate defaults will be used for options that are not specified.\n\nThe options supported varies from system to system and will depend on the\ndevice drivers used on those systems.\n\nConfigurations options can be read with the `getOptions` and `getOptionsSync`\nmethods.\n\n- mode - number, 2-bit, MODE0, MODE1, MODE2, or MODE3, default MODE0\n- chipSelectHigh - boolean, true for active high chip select, default false\n- lsbFirst - boolean, true for least significant bit first transfer, default\nfalse\n- threeWire - boolean, true for shared MISO/MOSI signals, default false\n- loopback - boolean, true for loopback mode, default false\n- noChipSelect - boolean, true for 1 device per bus, no chip select, default\nfalse\n- ready - boolean, true if device pulls low to pause, default false\n- bitsPerWord - number, 8-bit, device word size, default 8\n- maxSpeedHz - number, 32-bit, device clock frequency in Hertz, default system\nspecific\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/fivdi/spi-device.git"
  },
  "scripts": {
    "install": "node-gyp rebuild",
    "test": "echo \"Tests can only be run manually from the command line.\" && exit 1"
  },
  "version": "2.0.4"
}
